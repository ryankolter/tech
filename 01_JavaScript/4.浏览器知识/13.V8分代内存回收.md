# V8分代内存回收

## 两种内存

1. 栈内存
    - 主要存放两种内容
        - 基本类型
        - 引用类型的内存地址

2. 堆内存
    - 主要存放js对象
    - Node.js对内存的 1.4GB 上限，就是指堆内存

## 两种内存回收方法

1. 引用计数法
    - 标记每个变量被引用的次数，一旦减少到0，代表成为孤儿，可以回收
    - 缺点：无法解决循环引用问题，永远不会减少到0

2. 标记清除法
    - 内存中变量之间会有关联，对象之间互相引用，会形成一棵以window对象作为根的树
        - 事件监听，DOM对象，BOM对象也可以作为根
    - 在堆中但不在树中的，称为不可达对象，就可以回收
    - 缺点：回收后，堆中会生成大量可用的碎片内存

## V8的分代回收

1. 把内存分为两部分
    - 新生代
        - 新对象刚开始都会在这里面
        - 使用Scavenge复制算法
            - 把新生代内存分为两半
                - 一边是From空间，用于存放对象
                - 另一边是To空间，处于空闲状态
            - 当From空间不足时，会启动垃圾回收算法，把还存活的复制到To空间，复制完成后，两边角色互换
        - 需要结合晋升机制，把长时间存活的对象放到一个更大更高效的空间
            - 晋升条件（任意一个）
                - 对象已经历过一次垃圾回收
                - 在To空间的占用超过25%
    - 老生代
        - 接收可能长时间存活的对象
        - 使用
            - 标记清除法
                - 日常标记出存活的对象，然后把其他清除
            - 标记压缩法
                - 当出现大量内存碎片，导致无法完整分配一块空间时，会启动这个算法，把存活对象向内存一端移动，执行速度较慢

2. 导致的问题
    - 全停顿
        - 垃圾回收时，会阻塞JavaScript的执行，这叫全停顿
        - 为了减少全停顿带来的体验问题，V8引入了增量标记、延迟清理等方法，把回收过程变成可拆分和停顿的