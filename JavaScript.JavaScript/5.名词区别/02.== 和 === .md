# == 和 === 

## `x == y`的比较规则

- 如果 x 与 y 类型相同
    - 返回严格全等比较的结果（x === y）
- 如果 x 和 y 类型不同，就可能需要转类型
    1. 如果 一个是null，另一个是undefined，就返回true
    2. 如果 一个是数字，另一个是字符串，就先把字符串换成数字（借助toNumber），再比较
    3. 如果 一个是布尔，另一个随意，那就先把布尔换成数字（借助toNumber），再比较
    4. 如果 一个是对象，另一个是字符串或数字或符号，则把对象换成原始类型（借助ToPrimitive），再比较
    5. 如果上面都不行，那返回false

## `x === y`的比较规则

- 如果 x 与 y 类型不同
    - 直接返回false
- 如果 x 和 y 类型相同
    1. 如果 都是undefined 或 都是null，就返回true
    2. 如果 都是数字
        - 只要其中一个是NaN，就返回false
        - 如果都是同样的正常数字，就返回true
        - 一个 +0，另一个 -0，也是true
        - 其他情况都是false
    3. 如果 都是字符串
        - 对比他们的单元序列，同样长度，同样的单元，就返回true
        - 其他情况都是false
    4. 如果 都是布尔
        - 如果 都是true 或 都是false，就返回true
    5. 如果 都是符号
        - 如果 指向同一个Symbol，就返回true
    6. 如果 都是对象
        - 如果 指向同一个对象，就返回true
    7. 如果上面都不行，那返回false

## ==的奇怪例子

- `null == undefined` 返回true

- `1 == true` 返回true， 但 `2 == true` 返回false

- `[] == ![]` 返回true，因为`![]`会由于高优先级转换为布尔，这里`[]`的布尔是true，所以右边的布尔是false，进而变成数字0，而左边又会转换成原始类型就是空字符串，进而变成数字0
    - 且 `[]==[]` 返回false，因为属于不同的引用
    - 而 `{}==!{}` 正常返回false

- `[] == false`返回true
    - [] == false
    - [] == 0
    - "" == 0
    - 0 == 0

- `!![] == true`返回true
    - !![] == true
    - !false == true
    - true == true

## ===的奇怪例子

- `NaN === NaN`返回false
    - 所以需要ES6引入的`Object.is(NaN,NaN)`做判断
